学习笔记
这周主要学习了DFS、BFS、贪心算法以及二分查找

深度优先算法(DFS):
    在树模型的搜索中，深度优先搜索方法从树的某个节点出发，递归检索该节点的子树，直到
    子树遍历完成，返回某一分支的完整路径。DFS通常使用递归实现。

广度优先算法(BFS):
    在树模型的搜索中，广度优先搜索方法从树的某个节点出发，每次将该节点的所有子节点添加到
    队列中，并将该节点出队，循环遍历该队列，直到该队列没有元素，则表示搜索遍历完成。BFS通常
    用于找出最短路径。

另外，区别于树模型的搜索，在图模型中DFS及BFS的搜索，通常需要添加visted数组，用于记录该节点是否
被访问过，以避免在图中出现环，导致重复计算

贪心算法:
    贪心算法并不是某种具体的算法，而是一种算法思想，贪心算法只根据当前的情况，选择当前最优的结果
    从而得到局部最优解，依次类推，得到最终全局的较优解。由于贪心算法只关注当前最优解，所以得出的
    结果往往不是全局最优解，但由于贪心算法无需保留计算过程中的状态，所以相较于回溯算法以及动态规划
    算法计算时间及空间有一定优势。贪心算法往往用于能证明通过局部最优解能得到全局最优解的问题或者
    用于对最终结果的精确性不高但对计算时间有严苛要求的问题。

二分查找:
    二分查找通常用于查找已排序数组(单调递增或单调递减)中的某个元素，每次找到通过取出中间下标的值，
    通过比较中间值与目标值(假设数组从小到大排列)，若与目标值相等，则返回中间值，若中间值比目标值小，
    则数组的右半区查找，若中间值比目标值大，则在数组的左半区查找。由于每次都取中间值比较，所以可以
    减少一半的搜索范围，时间复杂度为logN。

另外，通过对习题《搜索旋转排序数组》的练习，明白了二分查找不仅可以用在全局单调递增或递减的排序数组中，
也可以用于局部单调递增或递减的排序数组，只是判断目标值左半区还是右半区的条件需要变化，需要将中间值
与数组两端的值进行比较，若low值小于mid值，则说明数组左半区单调递增，此时判断目标值是否在左半区的区间内
即low <= taget < mid，若在该区间内，则继续在左半区寻找taget值，否则，若mid值小于high值，则说明数组在
右半区单调递增，此时判断目标值是否在右半区的区间内即mid <= taget < high，若在该区间内，则继续在右半区
寻找taget值。
代码如下:
```
    def search(self, nums: List[int], target: int) -> int:
        # 二分查找
        result = -1
        if nums:
            low, high = 0, len(nums) - 1
            while low <= high:
                mid = low + (high - low) // 2
                if nums[mid] == target:
                    return mid
                if nums[low] <= nums[mid]:
                    # 左侧升序
                    if nums[low] <= target < nums[mid]:
                        # 左侧查找
                        high = mid - 1
                    else:
                        low = mid + 1
                else:
                    # 右侧升序
                    if nums[mid] < target <= nums[high]:
                        # 右侧查找
                        low = mid + 1
                    else:
                        high = mid - 1
        return result
```