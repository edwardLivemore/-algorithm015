学习笔记
这周主要学习了泛型递归、树的递归、分治以及回溯算法。
泛型递归:
    寻找问题中的重复性，将复杂的问题分解为多个重复的子问题
    一般可将递归的模板写为:
    # ternimate : 递归的终止条件
    # process : 递归的处理
    # drill down : 调用下层递归
    # reverse state: 重置回滚状态
    递归时，不建议用人脑进行多层的递归模拟，一般只考虑当前层的处理

树的递归:
    类似于泛型递归，需要注意的是树的递归是对左子树或者右子树的递归，而不是左子节点或者右子节点
    树递归一般有以下几种顺序:
    前序遍历: 根->左子树->右子树
    中序遍历: 左子树->根->右子树
    后序遍历: 左子树->右子树->根
    层遍历: 逐层遍历

分治:
    运用递归的思想，寻找问题中的重复性，将大问题拆分成为多个子问题，需要注意的是，分治算法需要
    合并子问题的结果，并将结果返回，而不是单纯的调用下层递归。

回溯:
    运用递归的思想，寻找问题中的重复性，每次递归时，若发现不满足条件，则返回到上一层的状态，继续探索，
    类似于走迷宫或者优先深度遍历
    需要注意的是，回溯算法由于需要返回到上一层的状态，所以调用完下层递归后，需要重置或回滚状态，使状态
    改变为上一层的状态。
    另外通过对全排列II的习题练习，意识到在回溯算法中，提前剪枝能大大改善程序的执行效率，因为回溯算法
    可能会包含多个重复的状态

PS: 通过本周学习，学习到了python中的一些技巧，比如[i for i in range(n)]可以通过内置生成的迭代器返回
    数组集合，在回溯算法中，若递归的参数是数组，可以通过类似 sublist + [i] 的方式传递到下一层递归，
    且不需要要执行完递归后重置数组状态，因为sublist + [i]的方式会新建一个局部变量，所以当方法返回后，
    局部变量消失，数组会自动还原成原先的状态