学习笔记
经过一学期的算法训练营学习，收获颇深，下面进行下知识点的梳理，主要分为数据结构和算法两类:
数据结构:
数组:
    查询元素时间复杂度: O(1), 由于数组元素的地址是内存中一串连续的地址，所以支持随机访问，查询速度极快
    添加、删除元素时间复杂度: O(n), 当在数组中插入或删除元素时，需要将指定位置后的所有元素前移或后移
链表:
    查询元素时间复杂度: O(n), 由于链表中的元素不连续，所以需要挨个通过next遍历链表元素才能找到指定的元素
    添加、删除元素时间复杂度: O(1), 只需操作前序结点及后继结点即可
跳表:
    查询元素时间复杂度: O(logN), 在链表的基础上，增加多级索引，类似于二分查找，加快查询速度，但需增加额外的内存开销用来维护索引
    添加、删除元素时间复杂度: O(1), 需操作前序结点及后继结点的同时需要维护索引，但总体时间复杂度仍为O(1)
    跳表的思想是升维，以时间换空间
栈:
    先入后出
队列:
    先入先出
优先队列:
    队列内的元素按优先级排列，每次返回优先级最大(小)的元素
双端队列:
    结合队列和栈的数据特点，在队首和队尾都支持插入和删除元素，既能先入后出，也能先入先出
哈希表:
    通过散列函数将传入的值映射为数组的下标，当遇到哈希冲突，即不同的输入值映射为相同的下标时，可以通过增加
    链表的方式来解决冲突，链表元素增加时，可以通过红黑树或者跳表进行性能优化
    一般情况下，散列函数能将数据均匀的分布在数组中，哈希冲突的情况并不常见，所以哈希表的访问时间复杂度为O(1)
map:
    由key-value(键值对)形式组成的数据集合，key不重复但value可以重复，即一个key只对应一个value
集合:
    非重复元素的数据集合
树：
    由根节点开始，每个节点都有子节点，一层层往下延伸，最后一层的节点叫叶子节点
二叉树:
    特殊形式的树，需要满足当前节点大于左子节点且小于右子节点的条件
    遍历形式：
        前序遍历: 根->左子树->右子树
        中序遍历: 左子树->根->右子树(升序排列)
        后序遍历: 左子树->右子树->根
        按层遍历: 逐层返回自身及兄弟节点
堆:
    堆顶元素存放最大值或最小值, 常见的堆有二叉堆、斐波那契堆、严格斐波那契数列堆等
    大顶堆:
        堆顶元素为数组中的最大值
    小顶堆:
        堆顶元素为数组中的最小值
    时间复杂度:
        查询: O(1), 直接返回堆顶元素
        插入，删除: O(logN), 由于需要维护堆的性质，所以当堆内元素发生变化时，需要调整堆结构
    应用:
        优先级队列, 取TopK的数
二叉堆:
    特性:
        完全二叉树，且父节点的值总是大于(小于)子节点的值
    左子节点索引: 2*i + 1
    右子节点索引: 2*i + 2
    父节点索引: floor((i-1) / 2)
图:
    由点和边组成的数据结构
    度:
        度数为该顶点的边数，在无向图中，入度数等于出度数
    表示方法:
        邻接矩阵:
            由二维数组组成，优点是计算速度快，缺点是当点多边少时，浪费较多内存空间
        邻接表:
            由一维数组和链表组成，优点是占用内存空间少，缺点是受限于链表遍历，所以计算速度较慢
    种类:
        无向无权图、无向有权图、有向无权图、有向有权图
    遍历方法:
        深度优先遍历(DFS): 常用递归的方法实现遍历
        广度优先遍历(BFS): 按层遍历，常用优先队列的方法实现遍历
        由于图中会有环的存在，所以无论哪种遍历，都需要增加visited数组来判断该节点是否遍历过，以
        避免重复计算
单链表、树、图的关系:
    单链表是特殊的树(只有一个子节点)，树是特殊的图(无环图)

字典树:
    字典树，即Trie树，是一种树形结构的数据结构，将单词的每个字母加入到字典树中，生成出一条路径，
    在搜索时由于有路径的存在，可以有效减少不必要的搜索(类似于剪枝)，并且由于路径的存在，所以某
    个节点即为该节点后所有子树的前缀字符

并查集:
    并查集常用于解决快速判断某几个元素是否属于相同集合的问题，例如解决朋友圈的问题，首先，
    初始化并查集，生成一个数组，并将数组中每个元素的领头元素设置为自己，然后通过遍历数组，
    将具有相同性质的元素合并到一起(如将B的领头元素设置为A),最后可以通过压缩路径的方法，大大
    减少查询某个元素的领头元素的搜索时间，经过处理后，就能在并查集中快速判断某几个元素是否
    属于相同的集合。

AVL及红黑树:
    AVL及红黑树都是平衡二叉树，由于二叉树在极端情况下回退化成单链表，时间复杂度退化为O(n),所以
    在每次插入或删除节点时，需要对二叉树做平衡处理。
    AVL:
        计算某个节点左右子树的层数差，得出平衡因子(取值范围为:-1, 0, 1)，通过对平衡因子的判断，
        并以及左旋、右旋、左右旋、右左旋的操作，维持二叉树的平衡性。
    红黑树:
        从根到叶子的最长可能路径不多于最短可能路径的两倍。特性如下:
        1.每个节点要么是红色，要么是黑色
        2.根节点是黑色
        3.每个叶子节点为空节点且为黑色
        4.不能有相邻的红色节点
        5.从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点
    AVL与红黑树之间的比较:
        优点:
        由于AVL有平衡因子的存在，所以是严格的二叉平衡树，在查询效率上要比红黑树快，时间复杂度为O(log2N)
        缺点:
        在节点的删除和插入效率上，AVL不及红黑树，这是由于在插入删除元素时AVL需要更多的旋转操作。
        由于平衡因子的存在，AVL占用的空间更多，通常需要一个int来表示平衡因子，而红黑树只需要一个bit就能存储
        节点的类型(红或黑),所以红黑树更多的运用于数据库中


算法:
泛型递归:
    寻找问题中的重复性，将复杂的问题分解为多个重复的子问题
    一般可将递归的模板写为:
    # ternimate : 递归的终止条件
    # process : 递归的处理
    # drill down : 调用下层递归
    # reverse state: 重置回滚状态
    递归时，不建议用人脑进行多层的递归模拟，一般只考虑当前层的处理

分治:
    运用递归的思想，寻找问题中的重复性，将大问题拆分成为多个子问题，需要注意的是，分治算法需要
    合并子问题的结果，并将结果返回，而不是单纯的调用下层递归。

回溯:
    运用递归的思想，寻找问题中的重复性，每次递归时，若发现不满足条件，则返回到上一层的状态，继续探索，
    类似于走迷宫或者优先深度遍历
    需要注意的是，回溯算法由于需要返回到上一层的状态，所以调用完下层递归后，需要重置或回滚状态，使状态
    改变为上一层的状态。
    另外通过对全排列II的习题练习，意识到在回溯算法中，提前剪枝能大大改善程序的执行效率，因为回溯算法
    可能会包含多个重复的状态

动态规划:
    与递归、分治算法类似，共同点是找到重复的子问题，不同点是动态规划需要找到最优子结构，
    并在求解的过程中淘汰次优解。
    一般的，动态规划算法分为以下几个步骤：
    1. 找到重复子问题与最优子结构
    2. 定义状态(当前状态代表什么含义)
    3. 确定状态转移方程，在求解过程中淘汰次优解
    状态转移方程又可以分为一维dp数组或者二维(多维)dp数组，一维dp数组常用于解决较简单的问题，
    例如爬楼梯问题、求斐波那契数列问题、打家劫舍问题等，二维dp数组常见于解决两个字符串比较、
    路径计算等问题。
    同时，在优化dp方程时，通常可以运用降维的思想，将一维dp数组用n个变量代替，将二维dp数组用
    一维dp数组代替，以降低空间复杂度。另外在解决动态规划问题时，如何正确的初始化dp数组也是至关重要的

剪枝搜索:
    剪枝搜索的目的是通过预先通过某些判断，在搜索时减少不必要的重复搜索，从而大大提升搜索
    的效率，比如在解决N皇后的问题时，可以通过预先判断某个位置是否已出现在行、列、撇、捺
    这四种集合中，如果出现过，则跳过这个位置，这样就能避免重复搜索,判断如下:
    ```
    for col in range(n):
        if col not in queenlist and row + col not in pie and row - col not in na:
            helper(queenlist + [col], pie + [row + col], na + [row - col])
    ```

深度优先搜索:
    常用递归实现，沿着某个分支一路走到底，再逐级返回。常见于树的搜索

广度优先搜索:
    常用于寻找最短路径, 每次按当前层展开，逐个遍历当层节点，同时将当前节点的子节点放入到下一层中，
    再逐层返回

双向BFS搜索:
    双向BFS搜索是在BFS搜索的基础上的优化，即从两端开始搜索。单向BFS搜索时，从某一端开始，
    遍历该层中所有的节点，若遇到目标节点则返回层数，否则将该节点的子节点加入到下一层节点中，
    并且层数+1。而双向BFS的层数计算则是分为前段层数和后端层数，当遇到目标节点后，返回的结果
    为前端层数+后端层数。

启发式搜索:
    启发式搜索又称为A* Search，既不是深度优先搜索也不是广度优先搜索，而是优先级优先搜索，
    每次从优先级队列中选出优先级最高的元素，然后对该元素进行搜索。元素的优先级通过估价函数进行
    设置，所以启发式搜索的关键在于找到较好的估价函数。启发式搜索相对于DFS和BFS更加智能，在
    估价函数得当的情况下能更快的找到目标元素

位运算:
    常见的位运算操作有:
    <<: 左移(相当于乘法)
    >>: 右移(相当于除法)
    | : 或运算(有1则1)
    & : 与运算(有0则0)
    ~ : 取反运算(0转1, 1转0)
    ^ : 异或运算(不同为1, 相同为0)
    x & (~0 << n) : 将x最右边的n位清零
    (x >> n) & 1 : 获取x的第n位值
    x & ( 1 << n) : 获取x的第n位幂值
    x | (1 << n) : 仅将x的第n位置为1
    x & (~ (1 << n)) : 仅将x的第n位置为0
    x & ((1 << n) - 1) : 将x的最高位至n位清零
    x & (x - 1) : 清零最低位的1
    x & -x : 得到最低位的1

布隆过滤器:
    通过将输入的参数转化为0和1组成的bit，并判断该bit是否存在于缓存数组中，来判断
    这个参数是否存在。由于是位运算，所以查询效率远超一般的搜算算法。但布隆过滤器也有
    缺点，就是会发生误判，通过布隆过滤器得到的结果，如果为False则表示该参数肯定不存在，
    但若结果为True，则该参数有可能存在，所以布隆过滤器一般用于最外层的筛选过滤。

LRU缓存:
    通过哈希表和双向链表组成的结构，存储最近使用过的元素，当存储的元素个数达到阈值且有
    新元素加入时，则淘汰链表中队尾的元素(即最久未被访问的元素),同时，每次有新元素加入或
    被访问时，都将该元素移动到队首。

排序算法:
    比较类排序: 
        交换排序(冒泡排序、快速排序)
        插入排序(简单插入排序、希尔排序)
        选择排序(简单选择排序、堆排序)
        归并排序(二路归并排序、多路归并排序)
    非比较排序:
        计数排序、桶排序、基数排序
    冒泡排序(时间复杂度O(n * n), 稳定):
    ```
    class Solution(object):
    def bubleSort(self, nums):
        m = len(nums)
        for i in range(m - 1):
            for j in range(m - 1 - i):
                if nums[j] > nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
        return nums
    ```
    快速排序(时间复杂度O(n * logn), 不稳定):
    ```
    class Solution(object):
    def quickSort(self, nums):
        def myQuickSort(nums, begin, end):
            if begin >= end:
                return
            pivot = partition(nums, begin, end)
            myQuickSort(nums, begin, pivot - 1)
            myQuickSort(nums, pivot + 1, end)

        def partition(nums, begin, end):
            pivot = end
            counter = begin
            for i in range(begin, end):
                if nums[i] < nums[pivot]:
                    nums[i], nums[counter] = nums[counter], nums[i]
                    counter += 1
            nums[counter], nums[pivot] = nums[pivot], nums[counter]
            return counter

        if nums:
            myQuickSort(nums, 0, len(nums) - 1)
        return nums

    ```
    插入排序(时间复杂度O(n * n), 稳定):
    ```
    class Solution(object):
    def insertionSort(self, nums):
        m = len(nums)
        for i in range(1, m):
            num = nums[i]
            # 二分查找, 找到插入下标
            index, low, high = 0, 0, i - 1
            while low <= high:
                mid = low + ((high - low) >> 1 )
                if num == nums[mid]:
                    index = mid
                    break
                if num < nums[mid]:
                    high = mid - 1
                    index = high if high >= 0 else 0
                else:
                    low = mid + 1
                    index = low
            while i > index:
                nums[i] = nums[i - 1]
                i -= 1
            nums[index] = num

        return nums
    ```
    选择排序(时间复杂度O(n * n), 稳定):
    ```
    class Solution(object):
    def selectionSort(self, nums):
        m = len(nums)
        for i in range(m):
            min_index = i
            for j in range(i + 1, m):
                if nums[j] < nums[min_index]:
                    min_index = j
            nums[i], nums[min_index] = nums[min_index], nums[i]
        return nums
    ```
    堆排序(时间复杂度O(n * logn), 不稳定):
    ```
    import heapq
    from heapq import heapify, heappop, heappush
    class Solution(object):
        def heapSort(self, nums):
            if nums:
                heap = []
                heapify(heap)
                for i in nums:
                    heappush(heap, i)
                for i in range(len(nums)):
                    nums[i] = heappop(heap)
            return nums
    ```
    归并排序(时间复杂度O(n * logn), 稳定):
    ```
    class Solution(object):
    def mergeSort(self, nums):
        def myMergeSort(nums, low, high):
            if low >= high:
                return
            mid = low + ((high - low ) >> 1)
            myMergeSort(nums, low, mid)
            myMergeSort(nums, mid + 1, high)
            merge(nums, low, mid, high)
        
        def merge(nums, low, mid, high):
            temp = []
            i, j = low, mid + 1
            while i <= mid and j <= high:
                if nums[i] <= nums[j]:
                    temp.append(nums[i])
                    i += 1
                else:
                    temp.append(nums[j])
                    j += 1
            while i <= mid:
                temp.append(nums[i])
                i += 1
            while j <= high:
                temp.append(nums[j])
                j += 1
            nums[low:high + 1] = temp

        if nums:
            myMergeSort(nums, 0, len(nums) - 1)
        return nums

    ```
同时对《五毒神掌》的印象也很深刻，首先，做题最大的误区就是题目只做一遍，同时，做完一道题之后需要到国际站
去看高票回答，尽量使代码简洁，逻辑清晰没有冗余。
五遍刷题法中的五遍具体是指:1.新题照着题解临摹一遍 2.自己写一遍 3.一小时后写一遍 4.一周之后写一遍 5.面试前过一遍
最后一句话就是师父领进门，修行在个人，之后不断提升自己的内功(逻辑思维能力和数学归纳能力)，同时毕业也是新的开始，
祝算法训练营越办越好，有缘再见于江湖。